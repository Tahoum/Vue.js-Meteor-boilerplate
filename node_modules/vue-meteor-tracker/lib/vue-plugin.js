'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _lodash = require('lodash.omit');

var _lodash2 = _interopRequireDefault(_lodash);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function defaultSubscription() {
  var _Meteor;

  return (_Meteor = Meteor).subscribe.apply(_Meteor, arguments);
}

exports.default = {
  install: function install(Vue, options) {

    var isServer = Vue.prototype.$isServer;
    var vueVersion = parseInt(Vue.version.charAt(0));

    var defineReactive = Vue.util.defineReactive;


    Vue.config.meteor = {
      subscribe: defaultSubscription,
      freeze: false
    };

    for (var k in options) {
      Vue.config.meteor[k] = options[k];
    }

    var merge = Vue.config.optionMergeStrategies.methods;
    Vue.config.optionMergeStrategies.meteor = function (toVal, fromVal, vm) {
      if (!toVal) return fromVal;
      if (!fromVal) return toVal;

      var toData = Object.assign({}, (0, _lodash2.default)(toVal, ['subscribe', 'data']), toVal.data);
      var fromData = Object.assign({}, (0, _lodash2.default)(fromVal, ['subscribe', 'data']), fromVal.data);

      return Object.assign({
        subscribe: merge(toVal.subscribe, fromVal.subscribe)
      }, merge(toData, fromData));
    };

    function prepare() {
      this._trackerHandles = [];
      this._subsAutorun = {};
      this._subs = {};

      // $subReady state
      defineReactive(this, '$subReady', {});
    }

    function launch() {
      var _this = this;

      this._meteorActive = true;

      var meteor = this.$options.meteor;

      if (meteor) {

        var ssr = true;
        if (typeof meteor.$ssr !== 'undefined') {
          ssr = meteor.$ssr;
        }

        if (!isServer || ssr) {
          // Subscriptions
          if (meteor.subscribe || meteor.$subscribe) {
            var subscribeOptions = Object.assign({}, meteor.subscribe, meteor.$subscribe);
            for (var key in subscribeOptions) {
              (function (key, options) {
                var subscribe = function subscribe(params) {
                  return _this.$subscribe.apply(_this, [key].concat(_toConsumableArray(params)));
                };

                if (typeof options === 'function') {
                  if (isServer) {
                    subscribe(options.bind(_this)());
                  } else {
                    _this.$watch(options, function (params) {
                      subscribe(params);
                    }, {
                      immediate: true
                    });
                  }
                } else {
                  subscribe(options);
                }
              })(key, subscribeOptions[key]);
            }
          }

          var data = Object.assign({}, (0, _lodash2.default)(meteor, ['subscribe', 'data']), meteor.data);

          // Reactive data
          if (data) {
            for (var _key in data) {
              if (_key.charAt(0) !== '$') {
                (function (key, options) {
                  var func = void 0,
                      vueParams = void 0;
                  if (typeof options === 'function') {
                    func = options.bind(_this);
                  } else if (typeof options.update === 'function') {
                    func = options.update.bind(_this);
                    if (typeof options.params === 'function') {
                      vueParams = options.params.bind(_this);
                    }
                  } else {
                    throw Error('You must provide either a function or an object with the update() method.');
                  }

                  _this.$data[key] = null;
                  defineReactive(_this, key, null);

                  var computation = void 0;

                  var run = function run(params) {
                    var result = func(params);
                    if (result && typeof result.fetch === 'function') {
                      result = result.fetch();
                    }
                    if (Vue.config.meteor.freeze) {
                      result = Object.freeze(result);
                    }
                    _this[key] = result;
                  };

                  var autorun = function autorun(params) {
                    computation = _this.$autorun(function () {
                      run(params);
                    });
                  };

                  if (vueParams) {
                    if (isServer) {
                      autorun(vueParams.bind(_this)());
                    } else {
                      _this.$watch(vueParams, function (params) {
                        if (computation) {
                          _this.$stopHandle(computation);
                        }
                        autorun(params);
                      }, {
                        immediate: true,
                        deep: !!options.deep
                      });
                    }
                  } else {
                    autorun();
                  }
                })(_key, data[_key]);
              }
            }
          }
        }
      }
    }

    Vue.mixin({

      // Vue 1.x
      init: prepare,
      // Vue 2.x
      beforeCreate: prepare,

      created: function created() {
        if (this.$options.meteor && !this.$options.meteor.$lazy) {
          launch.call(this);
        }
      },


      destroyed: function destroyed() {
        this.$stopMeteor();
      },

      methods: {
        $subscribe: function $subscribe() {
          var _this2 = this;

          for (var _len = arguments.length, args = Array(_len), _key2 = 0; _key2 < _len; _key2++) {
            args[_key2] = arguments[_key2];
          }

          if (args.length > 0) {
            /* if (isServer) {
              return {
                isReady: () => true,
                stop () {},
              }
            } else { */
            var key = args[0];
            var oldSub = this._subs[key];
            var handle = Vue.config.meteor.subscribe.apply(this, args);
            this._trackerHandles.push(handle);
            this._subs[key] = handle;

            // Readiness
            if (typeof handle.ready === 'function') {
              defineReactive(this.$subReady, key, false);
              if (this._subsAutorun[key]) {
                this._subsAutorun[key].stop();
              }
              var autorun = this.$autorun(function () {
                var ready = _this2.$subReady[key] = handle.ready();
                // Wait for the new subscription to be ready before stoping the old one
                if (ready && oldSub) {
                  _this2.$stopHandle(oldSub);
                }
              });
              this._subsAutorun[key] = autorun;
            }

            return handle;
            // }
          } else {
            throw new Error('You must provide the publication name to $subscribe.');
          }
        },
        $autorun: function $autorun(reactiveFunction) {
          /* if (isServer) {
            return {
              stop () {},
            }
          } else { */
          var handle = Tracker.autorun(reactiveFunction);
          this._trackerHandles.push(handle);
          return handle;
          // }
        },
        $stopHandle: function $stopHandle(handle) {
          handle.stop();
          var index = this._trackerHandles.indexOf(handle);
          if (index !== -1) {
            this._trackerHandles.splice(index, 1);
          }
        },
        $startMeteor: function $startMeteor() {
          if (!this._meteorActive) {
            prepare.call(this);
            launch.call(this);
          }
        },
        $stopMeteor: function $stopMeteor() {
          if (this._meteorActive) {
            //Stop all reactivity when view is destroyed.
            this._trackerHandles.forEach(function (tracker) {
              try {
                tracker.stop();
              } catch (e) {
                console.error(e, tracker);
              }
            });
            this._trackerHandles = null;
            this._meteorActive = false;
          }
        }
      }

    });
  }
};